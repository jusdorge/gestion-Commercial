/*
 * la licence de ce projet est accorder 
 * a l'entreprise bbs benhaddou brother's software
 * marque deposer aupr�s des autorit�s responsable * 
 */
package CommerceApp;

import Adapters.JDBCAdapter;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.DirectoryIteratorException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFileChooser;
import javax.swing.SwingWorker;

/**
 *
 * @author DELL
 */
public class RestoreInternalFrame extends javax.swing.JInternalFrame {
    static JDBCAdapter table;
    private ArrayList lastedUpdates;
    /**
     * Creates new form RestoreInternalFrame
     */
    public RestoreInternalFrame() {
        lastedUpdates = new ArrayList();
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        progressBar = new javax.swing.JProgressBar();
        directoryTextField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        restoreDirectory = new javax.swing.JButton();
        restoreButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        textArea = new javax.swing.JTextArea();
        quitButton = new javax.swing.JButton();

        jLabel1.setBackground(new java.awt.Color(0, 0, 0));
        jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 0, 0));
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("RESTAURATION");
        jLabel1.setOpaque(true);

        progressBar.setForeground(new java.awt.Color(51, 255, 51));
        progressBar.setMaximum(850);

        jLabel2.setText("path");

        restoreDirectory.setText("Directory");
        restoreDirectory.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restoreDirectoryActionPerformed(evt);
            }
        });

        restoreButton.setText("Restaurer");
        restoreButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restoreButtonActionPerformed(evt);
            }
        });

        textArea.setColumns(20);
        textArea.setRows(5);
        jScrollPane1.setViewportView(textArea);

        quitButton.setText("Quitter");
        quitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                quitButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(directoryTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(restoreDirectory, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(restoreButton, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addComponent(jScrollPane1)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(quitButton))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(directoryTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(restoreDirectory)
                    .addComponent(restoreButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(quitButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void restoreDirectoryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restoreDirectoryActionPerformed
        File dir = new File("C:\\");
        JFileChooser chooser = new JFileChooser();
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        chooser.setCurrentDirectory(dir);
        chooser.showOpenDialog(this);
        File f = chooser.getSelectedFile();
        directoryTextField.setText(f.getAbsolutePath());        
    }//GEN-LAST:event_restoreDirectoryActionPerformed

    private void restoreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restoreButtonActionPerformed
        SwingWorker<Void, String> worker = new SwingWorker<Void, String>(){
            @Override
            protected Void doInBackground() throws Exception {
                publish("Debut de la restauration...");
                Thread.sleep(1000);
                ////////    process Restore   ///////////////
                table = JDBCAdapter.connect();
                
                if (table.ErrorExists()){
                    
                    publish(table.getErrorMessage());
                    publish(table.getErrorCause());
                
                    table =JDBCAdapter.connect_C1();
                }else{
                    String sql0;
                    sql0 = "DROP DATABASE C1";
                    table.executeUpdate(sql0);
                    publish("supprimer la base...");
                }
                
                String sql1 = "CREATE DATABASE C1";
                String sql2 = "USE C1";
                
                progressBar.setValue(1);
                
                table.executeUpdate(sql1);
                if (table.getUpdateError()){
                    publish(table.getErrorMessage());
                    publish(table.getErrorCause());
                }
                progressBar.setValue(2);
                publish("création d'une nouvelle base de donnée");
                table.executeUpdate(sql2);
                if (table.getUpdateError()){
                    publish(table.getErrorMessage());
                    publish(table.getErrorCause());
                }
                progressBar.setValue(3);
                int s = 0;
                int numberTable = 0;
                BufferedReader inputStream = null;
                try {
                    inputStream = new BufferedReader(new FileReader(
                            directoryTextField.getText() + "\\"+ 
                                    "createSql.sql"));
                    String l;
                    int i = 3;
                    publish("Création des tables...");
                    Thread.sleep(1000);
                    String query = "";
                    
                    while ((l = inputStream.readLine()) != null) {
                        i += 1;
                        
                        progressBar.setValue(i);
                        if (!l.equals("END")){
                            query += l;
                            
                        }else{
                            numberTable += 1;
                            table.executeUpdate(query);
                            if (table.getUpdateError()){
                                publish(table.getErrorMessage());
                                publish(Integer.toString(table.getErrorNumber()));
                                publish(table.getErrorCause());
                            }
                            if (table.getUpdateError()){
                                lastedUpdates.add(query);
                            }
                            // si l'execution se fait avec erreurs ajouter 
                            // a la liste d"erreurs;
                            publish(query + "\n");
                            query = "";
                        }   
                    }
                    //execute the lasted updates;
                    int ii = i;
                    while (!lastedUpdates.isEmpty()){
                        ii += 1;
                        publish("les erreurs de creation : ");
                        publish("__________________________");
                        for (int j = 0;  j < lastedUpdates.size(); j++){
                            publish((String)lastedUpdates.get(j));
                            ii += 1;
                            progressBar.setValue(ii);
                        }
                        
                        
                        for (int j=0; j < lastedUpdates.size(); j++){
                            table.executeUpdate((String)lastedUpdates.get(j));
                            ii += 1;
                            progressBar.setValue(ii);
                            publish((String)lastedUpdates.get(j));
                            if(!table.getUpdateError()){
                                lastedUpdates.remove(j);
                            }else{
                                publish(table.getErrorMessage());
                                publish(Integer.toString(table.getErrorNumber()));
                                publish(table.getErrorCause());
                            }
                        }
                        
                        publish("les erreurs restantes : " + lastedUpdates.size());
                    }
                    s = ii;
                } finally {
                    if (inputStream != null) {
                        inputStream.close();
                    }
                }
                String [] fileNames;
                fileNames = new String[numberTable + 1];
                int jj = s;
                int i = 0;
                String location;
                table = JDBCAdapter.connect();
                Path dir = Paths.get(directoryTextField.getText()) ;
                try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
                    publish("Iteration des fichiers a charger :");
                    System.out.println("Iteration des fichiers a charger :");
                    for (Path file: stream) {
                        jj += 1;
                        progressBar.setValue(jj);
                        String fn = file.getFileName().toString();
                        if (!fn.equals("createSql.sql") && !fn.equals("null.sql")){
                            fileNames[i] = fn.substring(0,fn.length()- 4);
                            publish(fileNames[i]);
                            System.out.println(fileNames[i]);
                        }
                        i += 1;
                    }
                } catch (IOException | DirectoryIteratorException x) {
                    // IOException can never be thrown by the iteration.
                    // In this snippet, it can only be thrown by newDirectoryStream.
                    System.err.println(x);
                    publish(x.getMessage());
                }    
                table.executeUpdate("USE C1");
             
                System.out.println("nombre de table dans la base de données :"
                        + numberTable + 1);
                int jjj = jj;
                int j=0;
                publish("Chargement des fichiers lu dans les tables...");
                lastedUpdates = new ArrayList();
                for(String f:fileNames){
                    System.out.println(j + "-" + f);
                    location = doubleBlackSlash(directoryTextField.getText()) + "/" 
                                + f + ".sql";
                    String sql = "LOAD DATA LOCAL INFILE '" +
                            location + "' INTO TABLE " + f;
                    publish(sql );
                    System.out.println(sql);
                    publish(location );
                    table.executeUpdate(sql);
                    if (table.getUpdateError()){
                        lastedUpdates.add(sql);
                        publish(Integer.toString(table.getErrorNumber())
                                    + "-" + table.getErrorCause());
                    }
                    jjj += 1;
                    progressBar.setValue(jjj);
                    publish("le fichier chargé est :" + f );
                    j += 1;
                }
                int counter = jjj;
                while(lastedUpdates.size() > 1){
                    for (int ia=0; ia < lastedUpdates.size(); ia ++){
                        counter += 1;
                        progressBar.setValue(counter);
                        table.executeUpdate((String)lastedUpdates.get(ia));
                        publish((String)lastedUpdates.get(ia));
                        if (!table.getUpdateError()){
                            lastedUpdates.remove(ia);
                        }else{
                            publish("les erreures restantes :");
                            System.out.println("les erreures restantes :");
                            publish("________________________");
                            for (int a = 0; a < lastedUpdates.size(); a++){
                                publish((String)lastedUpdates.get(a));
                                System.out.println((String)lastedUpdates.get(a));
                            }
                            publish(table.getErrorCause());
                            publish(Integer.toString(table.getErrorNumber()));
                            publish(table.getErrorMessage());
                        }
                    }
                }
                return null;
            }
            @Override
            protected void process(List<String> chunks) {
                textArea.selectAll();
                for (String line: chunks){
                    textArea.append(line);
                    textArea.append("\n");
                }
            }
            @Override
            protected void done() {
                if(isCancelled()){
                    publish("Annulé");
                }else{
                    publish ("Terminé");
                }
                
            }
        };
        worker.addPropertyChangeListener(new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                if(evt.getPropertyName().equals("progress")){
                    progressBar.setValue((Integer)evt.getNewValue());
                }
            }
        });
        worker.execute();
    }//GEN-LAST:event_restoreButtonActionPerformed

    private void quitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitButtonActionPerformed
        dispose();
    }//GEN-LAST:event_quitButtonActionPerformed
    private static String doubleBlackSlash(String text) {
        String result = "";                        
        for (int i =0;i < text.length(); i++){
            if (text.charAt(i)== '\\' ){
                result += "/";
            }else{
                result += text.charAt(i);
            }
        }
        textArea.append(result);
        return result;
    }
    
    private static String extractFile(String str) {
        String result = "";
        int end = str.indexOf("(");
        result = str.substring(13, end - 1);
        return result;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField directoryTextField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JButton quitButton;
    private javax.swing.JButton restoreButton;
    private javax.swing.JButton restoreDirectory;
    private static javax.swing.JTextArea textArea;
    // End of variables declaration//GEN-END:variables
}

